---
title: "question3"
author: "Ermioni Athanasiadi"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(haven)
library(tidyverse)
library(patchwork)
library(pROC)
library(nlme)
library(data.table)
library(broom)

```


```{r}
setwd("./../data")

filename <- "alzheimer25.sas7bdat"

dat <- read_sas(filename)
dat_dt <- setDT(read_sas(filename))
```


# Q4: Two-stage analysis

We will build a model in two stages:

Stage 1: Separate linear regression model for each subject --> we predict the outcome of interest
Stage 2: Model for the different subject-specific coefficients --> we predict the coefficients

Since we have several coefficients in each subject-model, we will have to model each of these coefficient vectors for each subject


Time is the predictor for our stage 1 model.

Stage 2 predictors: 

- sex
- age
- trial

- edu
- job 
- adl 
- wzc

- bmi
- cdrsb 
- abpet 
- taupet

However, if understood correctly, a two-stage analysis for n subejcts would require n regression models in stage 1.
This corresponds to n = 1253 models, or n = 1106 if we exclude subjects with only 1 observation for the outcome of interest.

We know from the lectures that two-stage modeling will yield an acceptable marginal model if most of the variance is found between subjects.


```{r}
# only subjects with > 1 obs
stage1_coefs <- dat_long_cmpl2 %>%
  select(patid, time, bprs) %>%
  group_by(patid) %>%
  summarise(patid = first(patid),
            #model = lm(bprs ~ time, data = .),
            beta0 = coef(lm(bprs ~ time))[1],
            beta1 = coef(lm(bprs ~ time))[2],
            beta2 = coef(lm(bprs ~ time))[3],
            beta3 = coef(lm(bprs ~ time))[4],
            beta4 = coef(lm(bprs ~ time))[5],
            beta5 = coef(lm(bprs ~ time))[6]
            )

# also with n = 147 subjects with 1 obs -> but respective betas are NA
stage1_coefs_num <- dat_long_cmpl %>%
  select(patid, time_num, bprs) %>%
  group_by(patid) %>%
  summarise(patid = first(patid),
            #model = lm(bprs ~ time, data = .),
            beta0 = coef(lm(bprs ~ time_num))[1],
            beta1 = coef(lm(bprs ~ time_num))[2]
            )
```


Stage 2 Model:
```{r}
stage2_covars <- dat_long_cmpl %>% distinct(patid, age, sex, trial, edu, bmi, job, adl, wzc)  # , cdrsb, abpet, taupet

```

If we want to include time-varying predictors like the biomarkers or cognitive ratings, how to obtain a distinct set of covariates per subject? It will have more than 1 row.


```{r}
df_twostage <- left_join(stage1_coefs, stage2_covars, by = "patid")

m_beta0 <- lm(beta0 ~ age + sex + trial + edu + bmi + job + adl + wzc, data = df_twostage)

m_beta1 <- lm(beta1 ~ age + sex + trial + edu + bmi + job + adl + wzc, data = df_twostage)


summary(m_beta0)
summary(m_beta1)

```

We can see that sex doesnt seem to explain any variance in BPRS, neither at baseline nor over time. Except for sex and education, all covariates explain initial differences between patients at the start of the trial.

Education, BMI, WZC and sex do not explain much difference in the change over time of patients' BPRS. Job, ADL, Trial center and age are important.


Remove objects not needed anymore
```{r}
rm(stage1_coefs, stage1_coefs_num, stage2_covars)
```

#### ADD: visualize the two-step model approach


```{r}

dfs_by_patid <- by(dat_long_cmpl, dat_long_cmpl$patid, identity)

```







Model with continuous time 
```{r}

dat2 <- dat %>%
  filter(!patid %in% patid[is.na(bprs1)])

reshape_dat <- function(dat) {
    dat_long <- dat %>%
        pivot_longer(
            cols = matches("^(bprs|cdrsb|abpet|taupet)\\d+"),
            names_to = c(".value", "time"),
            names_pattern = "(.+)(\\d+)"
        )
    dat_long
}

to_factor <- function(dat) {
    dat <- dat %>%
        mutate(
            sex = as.factor(sex),
            edu = as.factor(edu),
            trial = as.factor(trial),
            job = as.factor(job),
            wzc = as.factor(wzc),
        )
    dat
}

dat2 <- to_factor(dat2)
dat_long2 <- reshape_dat(dat2)


dat_long2 <- dat_long2 %>%
    mutate(
        time = as.factor(time),  # levels 0-6
        time.num = as.numeric(as.character(time)) # values 0-6
    )


# also with n = 147 subjects with 1 obs -> but respective betas are NA
stage1_coefs_num <- dat_long2 %>%
  select(patid, time.num, bprs) %>%
  group_by(patid) %>%
  summarise(patid = first(patid),
            #model = lm(bprs ~ time, data = .),
            beta0 = coef(lm(bprs ~ time.num))[1],
            beta1 = coef(lm(bprs ~ time.num))[2]
            )


# Histogram for beta0
p_beta0 <- ggplot(stage1_coefs_num, aes(x = beta0)) +
  geom_histogram(bins = 30, color = "black", fill = "#603655") +
  labs(
    title = "Empirical distribution of β0",
    x = "β0 (intercepts)",
    y = "Count"
  ) +
  theme_minimal()

# Histogram for beta1
p_beta1 <- ggplot(stage1_coefs_num, aes(x = beta1)) +
  geom_histogram(bins = 30, color = "black", fill = "#c49235") +
  labs(
    title = "Empirical distribution of β1",
    x = "β1 (slopes)",
    y = "Count"
  ) +
  theme_minimal()

# Print them
p_beta0
p_beta1

library(patchwork)

(p_beta0 | p_beta1)


baseline_covariates <- dat2 %>%
  group_by(patid) %>%
  slice(1) %>%
  select(patid, age, sex, trial, edu, bmi, inkomen, job, adl, wzc, cdrsb0, abpet0, taupet0) %>%
  ungroup()

# Merge the Stage 1 coefficients with the baseline covariates
stage2_dat <- left_join(stage1_coefs_num, baseline_covariates, by = "patid")

ols_beta0 <- lm(beta0 ~ age + sex + trial + edu + bmi + 
                   inkomen + job + adl + wzc + cdrsb0 + abpet0 + taupet0, 
                   data = stage2_dat)

ols_beta1 <- lm(beta1 ~ age + sex + trial + edu + bmi + 
                   inkomen + job + adl + wzc + cdrsb0 + abpet0 + taupet0, 
                   data = stage2_dat)


stage2_model <- lm(cbind(beta0, beta1) ~ age + sex + trial + edu + bmi + 
                   inkomen + job + adl + wzc + cdrsb0 + abpet0 + taupet0, 
                   data = stage2_dat)

# Extract residuals from the multivariate model
resids <- residuals(stage2_model)

# Calculate the correlation matrix
cor(resids)

# 3. View Results
summary(stage2_model)

```

