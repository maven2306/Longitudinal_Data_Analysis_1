---
title: "Question 5"
author: "Rafke Niemans"
date: "`r Sys.Date()`"
output:
  html_document:
    # df_print: paged
---


```{r setup, include=FALSE}
libraries <- c(
  "haven", "dplyr", "tidyr", "ggplot2", "reshape2",
  "viridis", "knitr", "kableExtra", "nlme", "lmerTest"
)
# Install missing packages
for (pkg in libraries) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

# Load all packages
invisible(lapply(libraries, library, character.only = TRUE))

setwd("./../data")
dat <- read_sas("alzheimer25.sas7bdat")
```

```{r}
reshape_dat <- function(dat) {
    dat_long <- dat %>%
        pivot_longer(
            cols = matches("^bprs\\d+"),           # ⬅ ONLY bprs0, bprs1, ..., bprs6
            names_to = c(".value", "time"),
            names_pattern = "(.+)(\\d+)"
        )

    dat_long
}


to_factor <- function(dat_long) {

    dat_long <- dat_long %>%
        mutate(
            time = as.factor(time),  # coded 0–6, still fine
            sex = as.factor(sex),
            edu = as.factor(edu),
            trial = as.factor(trial),
            job = as.factor(job),
            wzc = as.factor(wzc),
            time_num = as.numeric(as.character(time))  # coded 0–6
        )
    dat_long
}


dat_long <- reshape_dat(dat)
dat_long <- to_factor(dat_long)


```

## Q5. 

Formulate a plausible random-effects model. Fit your model, and compare the results with those from the multivariate model. 


Choose the Random-Effects Structure
We use AIC and BIC instead than a LRT because of the boundary issue 
```{r}
m1 <- lm(bprs ~ time_num * (sex + age + wzc + adl + job) + taupet0 + abpet0 + cdrsb0, data = dat_long)

summary(m1)
m2 <- lmer(bprs ~ time_num * (sex + age + wzc + adl + job) + taupet0 + abpet0 + cdrsb0 + (1 | patid),
           data = dat_long, REML = TRUE) # Is var(slope) and cor(slope,intercept) = 0? 

m3 <- lmer(bprs ~ time_num * (sex + age + wzc + adl + job) + taupet0 + abpet0 + cdrsb0 + (time_num | patid),
           data = dat_long, REML = TRUE) # model with random intercept and slope for patid

m4 <- lmer(bprs ~ time_num * (sex + age + wzc + adl + job) + taupet0 + abpet0 + cdrsb0 + (1 | trial/patid),
           data = dat_long, REML = TRUE) # Is var(slope) and cor(slope,intercept) = 0? 

m5 <- lmer(bprs ~ time_num * (sex + age + wzc + adl + job) + taupet0 + abpet0 + cdrsb0 + (time_num | trial/patid), 
           data = dat_long, REML = TRUE) # model with random intercept and slope for patid and trial

m4.5 <- lmer(bprs ~ time_num * (sex + age + wzc + adl + job) + taupet0 + abpet0 + cdrsb0 + (1 | trial) + (time_num | patid),
             data = dat_long,REML = TRUE) # model with random intercept and slope for patid and only random intercept for trial


# patid and trial

summary(m4.5)
results <- data.frame(
  Model = c("m1", "m2", "m3", "m4", "m5", "m4.5"),
  AIC = AIC(m1, m2, m3, m4, m5, m4.5),
  BIC = BIC(m1, m2, m3, m4, m5, m4.5)
)


print(results)

```

We proceed with the random-effects structure of model m4.5 

Now we check the residual correlation structure
```{r}

library(nlme)
library(tidyverse)
library(reshape2)

# maximal fixed-effects formula
formula_fe <- bprs ~ time_num * (sex + age + wzc + adl + job) + taupet0 + abpet0 + cdrsb0

# Model 1: Random intercept for trial, Random intercept + slope for patid
model_no_corr <- lme(
  fixed = formula_fe,
  data = dat_long,
  # We use a list to specify different structures for the nested levels
  random = list(trial = ~ 1, patid = ~ time_num), 
  method = "REML",
  na.action = na.omit 
)

### Calculate residual correlation matrix 
# Note: We extract data directly from the model object to ensure 
# rows align perfectly (handling na.omit correctly)
residuals_df <- data.frame(
  patid = model_no_corr$groups$patid,
  trial = model_no_corr$groups$trial,
  # Extract time_num corresponding to the rows actually used in the model
  time_num = getData(model_no_corr)$time_num, 
  residual = residuals(model_no_corr, type = "normalized")
)

residuals_wide <- residuals_df %>%
  pivot_wider(
    id_cols = patid,
    names_from = time_num,
    values_from = residual,
    names_prefix = "Year_"
  )

# Select only the columns containing residuals
residual_columns <- residuals_wide %>%
  select(starts_with("Year_"))

# Calculate the matrix
correlation_matrix <- cor(residual_columns, use = "pairwise.complete.obs")

melted <- melt(correlation_matrix)

# Plotting
ggplot(melted, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile(color = "white", linewidth = 0.4) + 
  scale_fill_gradient2(
    low = "#4575b4", mid = "white", high = "#d73027", midpoint = 0,
    limits = c(-1, 1),
    name = "Correlation (-1 : 1)"
  ) +
  coord_fixed() + 
  labs(
    title = "Correlation Heatmap",
    subtitle ="Correlation of the within-subject residuals",
    x = NULL, y = NULL
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 11, face = "bold"),
    axis.text.y = element_text(size = 11, face = "bold"),
    plot.title = element_text(size = 18, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 13, hjust = 0.5, color = "gray30"),
    panel.grid = element_blank(),
    legend.position = "right",
    legend.title = element_text(size = 12, face = "bold"),
    legend.text = element_text(size = 10)
  )

```
The residual correlation matrix seems to suggest very little correlation between the residuals. We might try to fit models with Compound Symmetry and AR(1) structures and compare them to the model that assumes independence. 

```{r}
# Model 2: Compound Symmetry residual correlation
model_compsymm <- lme(
  fixed = formula_fe,
  data = dat_long,
  # Random: Intercept only for trial, Slope+Intercept for patid
  random = list(trial = ~ 1, patid = ~ time_num), 
  # Correlation: Within-subject (patid nested in trial)
  correlation = corCompSymm(form = ~ 1 | trial/patid), 
  method = "REML",
  na.action = na.omit 
)

# Compare Model 1 (No correlation) vs Model 2 (CompSymm)
anova(model_no_corr, model_compsymm)


# Model 3: AR(1) residual correlation
model_ar1 <- lme(
  fixed = formula_fe,
  data = dat_long,
  # Random: Intercept only for trial, Slope+Intercept for patid
  random = list(trial = ~ 1, patid = ~ time_num),
  # Correlation: Within-subject, ordered by time_num
  correlation = corAR1(form = ~ time_num | trial/patid), 
  method = "REML",
  na.action = na.omit 
)

# Compare Model 1 (No correlation) vs Model 3 (AR1)
anova(model_no_corr, model_ar1)
```

Neither more complex model fit the data better than the simpler model that assumes indepndent residuals. We continue without modeling serial correlation of the within-subject residuals. 




Now we choose the mean structure
```{r}
# Refit m4.5 using ML instead of REML

m4.5 <- lmer(bprs ~ time_num * (sex + age + wzc + adl + job + taupet0 + abpet0 + cdrsb0) + (1 | trial) + (time_num | patid),
             data = dat_long,REML = FALSE) 
summary(m4.5)


```





```{r}
m4.5 <- lmer(bprs ~ time_num * (sex + age + wzc + adl + job + taupet0 + abpet0 + cdrsb0) + (1 | trial) + (time_num | patid),
             data = dat_long,REML = FALSE) 

summary(m4.5)

m5 <- lmer(bprs ~ time_num * (sex + age + adl + job + cdrsb0) + taupet0 + abpet0 + wzc + (1 | trial) + (time_num | patid),
             data = dat_long,REML = FALSE) 

summary(m5)
anova(m4.5, m5)
```


Final model 

```{r}
m5 <- lmer(bprs ~ time_num * (sex + age + adl + job + cdrsb0) + taupet0 + abpet0 + wzc + (1 | trial) + (time_num | patid),
             data = dat_long,REML = TRUE)

summary(m5)
```



```{r}
res <- resid(m5)
fit <- fitted(m5)
plot(fit, res)
abline(h = 0, col = 2)



# QQ plot of the residuals 
qqnorm(res); qqline(res)


hist(res, breaks = 40)

```

```{r}
# 1. Extract random effects
re <- ranef(m5)

# Optional: Set up a 1x3 plotting grid
par(mfrow = c(1, 3))

# --- Patient-level Random Intercepts ---
# Note: Use re$patid, not re$`patid:trial`
qqnorm(re$patid[, "(Intercept)"],
       main = "Patient Random Intercepts")
qqline(re$patid[, "(Intercept)"], col = "red")

# --- Patient-level Random Slopes ---
qqnorm(re$patid[, "time_num"],
       main = "Patient Random Slopes")
qqline(re$patid[, "time_num"], col = "red")

# --- Trial-level Random Intercepts ---
qqnorm(re$trial[, "(Intercept)"],
       main = "Trial Random Intercepts")
qqline(re$trial[, "(Intercept)"], col = "red")

# Reset plotting parameters
par(mfrow = c(1, 1))
```



```{r}
dat2 <- dat %>%
  filter(!patid %in% patid[is.na(bprs1)])

reshape_dat <- function(dat) {
    dat_long <- dat %>%
        pivot_longer(
            cols = matches("^(bprs|cdrsb|abpet|taupet)\\d+"),
            names_to = c(".value", "time"),
            names_pattern = "(.+)(\\d+)"
        )
    dat_long
}

to_factor <- function(dat) {
    dat <- dat %>%
        mutate(
            sex = as.factor(sex),
            edu = as.factor(edu),
            trial = as.factor(trial),
            job = as.factor(job),
            wzc = as.factor(wzc),
        )
    dat
}

dat2 <- to_factor(dat2)
dat_long2 <- reshape_dat(dat2)


dat_long2 <- dat_long2 %>%
    mutate(
        time = as.factor(time),  # levels 0-6
        time.num = as.numeric(as.character(time)) # values 0-6
    )


# also with n = 147 subjects with 1 obs -> but respective betas are NA
stage1_coefs_num <- dat_long2 %>%
  select(patid, time.num, bprs) %>%
  group_by(patid) %>%
  summarise(patid = first(patid),
            #model = lm(bprs ~ time, data = .),
            beta0 = coef(lm(bprs ~ time.num))[1],
            beta1 = coef(lm(bprs ~ time.num))[2]
            )


# Histogram for beta0
p_beta0 <- ggplot(stage1_coefs_num, aes(x = beta0)) +
  geom_histogram(bins = 30, color = "black", fill = "#603655") +
  labs(
    title = "Empirical distribution of β0",
    x = "β0 (intercepts)",
    y = "Count"
  ) +
  theme_minimal()

# Histogram for beta1
p_beta1 <- ggplot(stage1_coefs_num, aes(x = beta1)) +
  geom_histogram(bins = 30, color = "black", fill = "#c49235") +
  labs(
    title = "Empirical distribution of β1",
    x = "β1 (slopes)",
    y = "Count"
  ) +
  theme_minimal()

# Print them
p_beta0
p_beta1

library(patchwork)

(p_beta0 | p_beta1)


baseline_covariates <- dat2 %>%
  group_by(patid) %>%
  slice(1) %>%
  select(patid, age, sex, trial, edu, bmi, inkomen, job, adl, wzc, cdrsb0, abpet0, taupet0) %>%
  ungroup()

# Merge the Stage 1 coefficients with the baseline covariates
stage2_dat <- left_join(stage1_coefs_num, baseline_covariates, by = "patid")

ols_beta0 <- lm(beta0 ~ age + sex + trial + edu + bmi + 
                   inkomen + job + adl + wzc + cdrsb0 + abpet0 + taupet0, 
                   data = stage2_dat)

ols_beta1 <- lm(beta1 ~ age + sex + trial + edu + bmi + 
                   inkomen + job + adl + wzc + cdrsb0 + abpet0 + taupet0, 
                   data = stage2_dat)


stage2_model <- lm(cbind(beta0, beta1) ~ age + sex + trial + edu + bmi + 
                   inkomen + job + adl + wzc + cdrsb0 + abpet0 + taupet0, 
                   data = stage2_dat)

# Extract residuals from the multivariate model
resids <- residuals(stage2_model)

# Calculate the correlation matrix
cor(resids)

# 3. View Results
summary(stage2_model)
```


```{r}
library(dplyr)
library(ggplot2)
library(patchwork)
library(lme4)

# ==============================================================================
# STEP 1: Get the Data for Stage 2
# ==============================================================================
# We force patid to be character right here to avoid the join error
stage2_data <- stage1_coefs_num %>%
  mutate(patid = as.character(patid)) %>% 
  inner_join(dat_long %>% 
               mutate(patid = as.character(patid)) %>% # Force character here too
               group_by(patid) %>% 
               slice(1) %>% 
               select(patid, age, sex, adl, job, cdrsb0, taupet0, abpet0, wzc),
             by = "patid") %>%
  filter(!is.na(beta0) & !is.na(beta1))

# ==============================================================================
# STEP 2: Run Stage 2 Models & Get Residuals
# ==============================================================================

# Model for Intercepts (beta0)
# Predictors: All main effects from your LMM
lm_intercept <- lm(beta0 ~ age + sex + adl + job + cdrsb0 + taupet0 + abpet0 + wzc, 
                   data = stage2_data)

# Model for Slopes (beta1)
# Predictors: Only variables that interacted with time in your LMM
# Your LMM: time_num * (sex + age + adl + job + cdrsb0)
lm_slope <- lm(beta1 ~ age + sex + adl + job + cdrsb0, 
               data = stage2_data)

# Save the residuals (The "Unshrunk" deviations)
stage2_data$resid_intercept <- residuals(lm_intercept)
stage2_data$resid_slope <- residuals(lm_slope)

# ==============================================================================
# STEP 3: Get LMM Random Effects
# ==============================================================================
ran_eff <- ranef(m5)$patid
ran_eff$patid <- rownames(ran_eff)

# Rename and force patid to character
lmm_data <- ran_eff %>%
  mutate(patid = as.character(patid)) %>%
  rename(lmm_random_intercept = `(Intercept)`,
         lmm_random_slope = time_num)

# ==============================================================================
# STEP 4: Merge and Plot
# ==============================================================================
# Now both are characters, so this will work
plot_data <- inner_join(stage2_data, lmm_data, by = "patid")

# --- Plot 1: Intercept Deviations ---
p1 <- ggplot(plot_data, aes(x = resid_intercept, y = lmm_random_intercept)) +
  geom_point(alpha = 0.5, color = "#603655") +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Intercept Deviations",
       subtitle = "Comparison of Unexplained Variation",
       x = "Stage 2 Residuals (OLS - Predicted)",
       y = "LMM Random Intercepts (Shrunk)") +
  theme_minimal()

# --- Plot 2: Slope Deviations (The Shrinkage!) ---
p2 <- ggplot(plot_data, aes(x = resid_slope, y = lmm_random_slope)) +
  geom_point(alpha = 0.5, color = "#c49235") +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
  labs(title = "Slope Deviations",
       subtitle = "Note the 'tilt' indicating shrinkage",
       x = "Stage 2 Residuals (OLS - Predicted)",
       y = "LMM Random Slopes (Shrunk)") +
  theme_minimal()

# Show plots
p1 | p2
```






